from typing import Optional, Dict, Any
from pathlib import Path
import asyncio
import tempfile
from datetime import datetime
import yt_dlp
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery, BufferedInputFile, FSInputFile
from aiogram.filters import Command
from aiogram.exceptions import TelegramAPIError
from database import (
    check_user_exists,
    add_user,
    get_video,
    add_video,
    get_file,
    add_file,
    add_download,
    get_video_by_id
)
from keyboards import get_download_keyboard
from download_service import downloader


SUPPORTED_PLATFORMS = {
    'vk.com/video': 'vk',
    'vk.com/clip': 'vk', 
    'youtube.com': 'youtube',
    'youtu.be': 'youtube',
    'instagram.com': 'instagram',
    'tiktok.com': 'tiktok'
}

MAX_RETRY_ATTEMPTS = 3
TEMP_FILE_PREFIX = "video_download_"

user_router = Router()


class VideoDownloadError(Exception):
    """–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∞—è –æ—à–∏–±–∫–∞ –¥–ª—è –ø—Ä–æ–±–ª–µ–º —Å –∑–∞–≥—Ä—É–∑–∫–æ–π –≤–∏–¥–µ–æ"""
    pass


async def safe_delete_message(message: Message) -> None:
    """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
    try:
        await message.delete()
    except TelegramAPIError:
        # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è
        return


def get_error_message(error: Exception) -> str:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–Ω—è—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–µ"""
    error_text = str(error).lower()
    
    if "404" in error_text:
        return "‚ùå –í–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω–æ –±—ã–ª–æ —É–¥–∞–ª–µ–Ω–æ –∏–ª–∏ —Å—Å—ã–ª–∫–∞ –Ω–µ–≤–µ—Ä–Ω–∞."
    elif "deleted" in error_text:
        return "‚ùå –≠—Ç–æ –≤–∏–¥–µ–æ –±—ã–ª–æ —É–¥–∞–ª–µ–Ω–æ –∏ –±–æ–ª—å—à–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ."
    elif "private" in error_text:
        return "‚ùå –≠—Ç–æ –ø—Ä–∏–≤–∞—Ç–Ω–æ–µ –≤–∏–¥–µ–æ. –£ –±–æ—Ç–∞ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –Ω–µ–º—É."
    elif "copyright" in error_text:
        return "‚ùå –í–∏–¥–µ–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –∏–∑-–∑–∞ –Ω–∞—Ä—É—à–µ–Ω–∏—è –∞–≤—Ç–æ—Ä—Å–∫–∏—Ö –ø—Ä–∞–≤."
    elif "age" in error_text:
        return "‚ùå –í–∏–¥–µ–æ –∏–º–µ–µ—Ç –≤–æ–∑—Ä–∞—Å—Ç–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è. –ë–æ—Ç –Ω–µ –º–æ–∂–µ—Ç –µ–≥–æ –∑–∞–≥—Ä—É–∑–∏—Ç—å."
    elif "unavailable" in error_text:
        return "‚ùå –í–∏–¥–µ–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è."
    elif "too large" in error_text:
        return "‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –≤ Telegram (–º–∞–∫—Å–∏–º—É–º 50MB)."
    else:
        return f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–∏–¥–µ–æ: {str(error)}"


async def download_audio(url: str, output_path: str) -> bool:
    """–ó–∞–≥—Ä—É–∑–∫–∞ –∞—É–¥–∏–æ –∏–∑ –≤–∏–¥–µ–æ"""
    try:
        ydl_opts = {
            'format': 'worstaudio/worst',
            'outtmpl': output_path,
            'quiet': True,
            'no_warnings': True,
            'extract_audio': True,
            'audio_format': 'mp3',
        }
        
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            ydl.download([url])
            return True
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∞—É–¥–∏–æ: {str(e)}")
        return False


def format_duration(duration: int) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤ —á–∏—Ç–∞–µ–º—ã–π –≤–∏–¥"""
    hours = duration // 3600
    minutes = (duration % 3600) // 60
    seconds = duration % 60
    
    if hours > 0:
        return f"{hours}:{minutes:02d}:{seconds:02d}"
    return f"{minutes}:{seconds:02d}"


def get_initial_caption(info: Dict[str, Any]) -> str:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –≤–∏–¥–µ–æ"""
    title = info.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è').replace('&quot;', '"')
    author = info.get('author', 'Unknown').replace('&quot;', '"')
    source_url = info.get('source_url', '')
    duration = int(info.get('duration', '0'))
    
    return (
        f"<code>üçø {title}</code>\n"
        f"üîó {source_url}\n"
        f"üë§ –ê–≤—Ç–æ—Ä: #{author.replace(' ', '_')}\n"
        f"üìÖ –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y')}\n"
        f"‚è± –ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {format_duration(duration)}"
    )


def get_download_caption(info: Dict[str, Any], file_type: str, quality: Optional[str] = None) -> str:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–ø–∏—Å–∞–Ω–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –≤–∏–¥–µ–æ/–∞—É–¥–∏–æ"""
    title = info.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è').replace('&quot;', '"')
    author = info.get('author', 'Unknown').replace('&quot;', '"')
    source_url = info.get('source_url', '')
    duration = int(info.get('duration', '0'))

    resolutions = {
        "144": "256x144",
        "240": "426x240",
        "360": "640x360",
        "480": "852x480",
        "720": "1280x720",
        "1080": "1920x1080"
    }

    quality_str = ""
    if file_type == "video" and quality:
        quality_str = f"\nüì∫ –ö–∞—á–µ—Å—Ç–≤–æ: {resolutions.get(quality, '')}"
    elif file_type == "audio":
        quality_str = "\nüíø –¢–∏–ø: –ê—É–¥–∏–æ"

    return (
        f"<code>üçø {title}</code>\n"
        f"üîó {source_url}\n"
        f"üë§ –ê–≤—Ç–æ—Ä: #{author.replace(' ', '_')}\n"
        f"üìÖ –î–∞—Ç–∞: {datetime.now().strftime('%d.%m.%Y')}\n"
        f"‚è± –ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {format_duration(duration)}"
        f"{quality_str}"
    )


def get_platform(url: str) -> Optional[str]:
    """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã –∏–∑ URL"""
    for domain, platform in SUPPORTED_PLATFORMS.items():
        if domain in url.lower():
            return platform
    return None


@user_router.message(Command("start"))
async def cmd_start(message: Message) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start"""
    try:
        if not await check_user_exists(message.from_user.id):
            await add_user(message.from_user.id, message.from_user.username)
        await message.answer(
            "üëã –ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ –∏–∑ YouTube, Instagram, TikTok –∏–ª–∏ VK, "
            "–∏ —è –ø–æ–º–æ–≥—É —Ç–µ–±–µ –µ–≥–æ —Å–∫–∞—á–∞—Ç—å."
        )
    except Exception as e:
        await message.answer(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {str(e)}")


@user_router.message(
    lambda message: message.text and any(
        platform in message.text.lower() 
        for platform in SUPPORTED_PLATFORMS.keys()
    )
)
async def process_video_url(message: Message) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å URL –≤–∏–¥–µ–æ"""
    processing_msg = None
    try:
        url = message.text.strip()
        platform = get_platform(url)
        
        if not platform:
            platforms = ", ".join(SUPPORTED_PLATFORMS.keys())
            await message.answer(f"‚ùå –ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç—Å—è: {platforms}")
            return

        processing_msg = await message.answer("‚è≥ –ü–æ–ª—É—á–∞—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ...")
        
        video_info = await get_video(url)
        info = await downloader.get_video_info(url)
        
        if not info:
            if processing_msg:
                await processing_msg.edit_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∏–¥–µ–æ. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Å—ã–ª–∫—É.")
            return

        video_data = {
            'source_url': url,
            'title': info.get('title', '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è'),
            'author': info.get('author', 'Unknown'),
            'duration': info.get('duration', '0'),
            'thumbnail': info.get('thumbnail', ''),
            'platform': platform
        }

        if not video_info:
            video_id = await add_video(
                url=url,
                title=video_data['title'],
                author=video_data['author'],
                duration=video_data['duration'],
                thumbnail=video_data['thumbnail']
            )
        else:
            video_id = video_info['video_id']

        caption = get_initial_caption(video_data)
        keyboard = await get_download_keyboard(video_id, info)

        if processing_msg:
            await safe_delete_message(processing_msg)

        try:
            await message.answer_photo(
                photo=video_data['thumbnail'],
                caption=caption,
                parse_mode="HTML",
                reply_markup=keyboard
            )
        except TelegramAPIError:
            await message.answer(
                text=caption,
                parse_mode="HTML",
                reply_markup=keyboard
            )
            
    except Exception as e:
        error_message = get_error_message(e)
        
        if processing_msg:
            try:
                await processing_msg.edit_text(error_message)
            except TelegramAPIError:
                await message.answer(error_message)


async def send_large_video(message: Message, video_path: str, caption: str) -> Optional[Message]:
    """–û—Ç–ø—Ä–∞–≤–∫–∞ –±–æ–ª—å—à–æ–≥–æ –≤–∏–¥–µ–æ —Ñ–∞–π–ª–∞ —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏"""
    for attempt in range(MAX_RETRY_ATTEMPTS):
        try:
            with open(video_path, 'rb') as video:
                return await message.bot.send_video(
                    chat_id=message.chat.id,
                    video=FSInputFile(video_path),
                    caption=caption,
                    parse_mode="HTML"
                )
        except Exception as e:
            if attempt == MAX_RETRY_ATTEMPTS - 1:
                try:
                    with open(video_path, 'rb') as video:
                        buf = BufferedInputFile(
                            video.read(),
                            filename="video.mp4"
                        )
                        return await message.bot.send_video(
                            chat_id=message.chat.id,
                            video=buf,
                            caption=caption,
                            parse_mode="HTML"
                        )
                except Exception as e:
                    raise VideoDownloadError(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –≤–∏–¥–µ–æ –ø–æ—Å–ª–µ –≤—Å–µ—Ö –ø–æ–ø—ã—Ç–æ–∫: {str(e)}")
            else:
                await asyncio.sleep(1)
    return None


async def download_video(url: str, output_path: str, format_id: str, is_tiktok: bool = False,
                        is_youtube: bool = False, is_instagram: bool = False) -> None:
    """–ó–∞–≥—Ä—É–∑–∫–∞ –≤–∏–¥–µ–æ —Å —É—á–µ—Ç–æ–º –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã"""
    if is_tiktok:
        ydl_opts = {
            'format': 'best',
            'outtmpl': output_path,
            'quiet': True,
            'no_warnings': True,
            'merge_output_format': 'mp4'
        }
    elif is_youtube:
        ydl_opts = {
            'format': f'bestvideo[height<={format_id}][ext=mp4]+bestaudio[ext=m4a]/best[height<={format_id}][ext=mp4]/best[ext=mp4]',
            'outtmpl': output_path,
            'merge_output_format': 'mp4',
            'fragment_retries': 50,
            'retries': 50,
            'socket_timeout': 120,
            'quiet': True,
            'no_warnings': True,
            'cookiefile': 'cookies.txt',
            'http_chunk_size': 10485760
        }
    elif is_instagram:
        ydl_opts = {
            'format': 'best[ext=mp4]',
            'outtmpl': output_path,
            'quiet': True,
            'no_warnings': True,
        }
    else:
        ydl_opts = {
            'format': f'best[height<={format_id}]',
            'outtmpl': output_path,
            'quiet': True,
            'no_warnings': True
        }

    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        try:
            await asyncio.get_event_loop().run_in_executor(
                None, 
                lambda: ydl.download([url])
            )
        except Exception as e:
            raise VideoDownloadError(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤–∏–¥–µ–æ: {str(e)}")


@user_router.callback_query(F.data.startswith("dl_"))
async def process_download(callback: CallbackQuery) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ –∫–Ω–æ–ø–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏"""
    await callback.answer()
    
    try:
        _, video_id, format_id, file_type = callback.data.split("_")
        video_id = int(video_id)
    except ValueError as e:
        await callback.message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö –∫–Ω–æ–ø–∫–∏")
        return
    
    try:
        file_info = await get_file(video_id, format_id, file_type)
        db_video = await get_video_by_id(video_id)
        
        if not db_video:
            await callback.message.answer("‚ùå –í–∏–¥–µ–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö")
            return

        video_data = {
            'title': db_video['title'],
            'author': db_video['author'],
            'duration': db_video['duration'],
            'source_url': db_video['source_url'],
            'thumbnail': db_video['thumbnail_url']
        }

        if file_info:
            try:
                caption = get_download_caption(video_data, file_type, format_id)
                
                if file_type == 'video':
                    msg = await callback.message.answer_video(
                        video=file_info['telegram_file_id'],
                        caption=caption,
                        parse_mode="HTML"
                    )
                else:
                    msg = await callback.message.answer_audio(
                        audio=file_info['telegram_file_id'],
                        caption=caption,
                        parse_mode="HTML"
                    )
                await safe_delete_message(callback.message)
                return
            except TelegramAPIError as e:
                print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ñ–∞–π–ª–∞ –∏–∑ –∫—ç—à–∞: {str(e)}")

        with tempfile.TemporaryDirectory(prefix=TEMP_FILE_PREFIX) as temp_dir:
            try:
                await callback.message.edit_caption(
                    caption=f"{callback.message.caption}\n\nüì•‚åõÔ∏è –°–∫–∞—á–∏–≤–∞—é —Ñ–∞–π–ª... ‚åõÔ∏èüì•",
                    parse_mode="HTML",
                    reply_markup=None
                )

                file_name = f"video_{int(datetime.now().timestamp())}"
                temp_path = Path(temp_dir) / file_name

                is_tiktok = 'tiktok.com' in db_video['source_url']
                is_youtube = 'youtube.com' in db_video['source_url'] or 'youtu.be' in db_video['source_url']
                is_instagram = 'instagram.com' in db_video['source_url']

                if file_type == 'video':
                    temp_path = temp_path.with_suffix('.mp4')
                    await download_video(
                        db_video['source_url'],
                        str(temp_path),
                        format_id,
                        is_tiktok,
                        is_youtube,
                        is_instagram
                    )
                else:
                    temp_path = temp_path.with_suffix('.mp3')
                    success = await download_audio(video_data['source_url'], str(temp_path))
                    if not success:
                        raise VideoDownloadError("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∞—É–¥–∏–æ —Ñ–∞–π–ª")

                if not temp_path.exists() or temp_path.stat().st_size == 0:
                    raise VideoDownloadError("–§–∞–π–ª –Ω–µ –±—ã–ª –∑–∞–≥—Ä—É–∂–µ–Ω –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ")

                caption = get_download_caption(video_data, file_type, format_id)

                if file_type == 'video':
                    msg = await send_large_video(callback.message, str(temp_path), caption)
                    file_id = msg.video.file_id
                else:
                    msg = await callback.message.answer_audio(
                        audio=FSInputFile(str(temp_path)),
                        caption=caption,
                        parse_mode="HTML"
                    )
                    file_id = msg.audio.file_id

                await safe_delete_message(callback.message)

                file_size = temp_path.stat().st_size
                new_file_id = await add_file(
                    video_id=video_id,
                    telegram_file_id=file_id,
                    file_type=file_type,
                    size=file_size,
                    quality=format_id
                )

                await add_download(
                    user_id=callback.from_user.id,
                    video_id=video_id,
                    file_id=new_file_id
                )

            except Exception as e:
                error_message = get_error_message(e)
                try:
                    info = await downloader.get_video_info(video_data['source_url'])
                    keyboard = await get_download_keyboard(video_id, info)
                    await callback.message.edit_caption(
                        caption=f"{callback.message.caption}\n\n{error_message}",
                        parse_mode="HTML",
                        reply_markup=keyboard
                    )
                except Exception as inner_e:
                    await callback.message.edit_caption(
                        caption=f"{callback.message.caption}\n\n‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ: {str(inner_e)}",
                        parse_mode="HTML"
                    )

    except Exception as e:
        error_message = get_error_message(e)
        await callback.message.answer(error_message)


@user_router.callback_query(F.data == "size_limit")
async def process_size_limit(callback: CallbackQuery) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–µ–≤—ã—à–µ–Ω–∏—è –ª–∏–º–∏—Ç–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞"""
    await callback.answer(
        "‚ùå –§–∞–π–ª —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π (>50MB). –í—ã–±–µ—Ä–∏—Ç–µ –º–µ–Ω—å—à–µ–µ –∫–∞—á–µ—Å—Ç–≤–æ –∏–ª–∏ –∞—É–¥–∏–æ –≤–µ—Ä—Å–∏—é.",
        show_alert=True
    )


@user_router.message()
async def process_unknown_message(message: Message) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ –∏–∑ YouTube, Instagram, TikTok –∏–ª–∏ VK, "
        "–∏ —è –ø–æ–º–æ–≥—É –≤–∞–º –µ–≥–æ —Å–∫–∞—á–∞—Ç—å."
    )